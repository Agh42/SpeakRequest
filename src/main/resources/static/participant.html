<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>SPEEK.NOW - Participant View</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="description" content="SPEEK.NOW Participant View - Request speaking time and participate in meeting polls."/>
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website"/>
  <meta property="og:title" content="SPEEK.NOW - Join Meeting"/>
  <meta property="og:description" content="Join this meeting on SPEEK.NOW to request speaking time and participate in polls."/>
  
  <!-- Twitter -->
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:title" content="SPEEK.NOW - Join Meeting"/>
  <meta name="twitter:description" content="Join this meeting on SPEEK.NOW to request speaking time and participate in polls."/>
  
  <link rel="stylesheet" href="styles.css"/>
  <link rel="stylesheet" href="fontawesome/all.min.css"/>
  <script src="stomp.min.js"></script>
  <script src="purify.min.js"></script>
  <script src="metadata-loader.js"></script>
  <script src="share.js"></script>
  <style>
    /* Poll overlay styles (mobile-friendly) */
    .poll-overlay {
      position: fixed;
      inset: 0;
      display: none; /* shown via JS */
      align-items: center;
      justify-content: center;
      background: rgba(15,23,42,0.95); /* Dark background matching main theme */
      z-index: 9999;
    }

    .poll-overlay .panel {
      width: 100%;
      max-width: 720px;
      height: calc(var(--vh, 1vh) * 100);
      background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0));
      border: 1px solid rgba(255,255,255,.12);
      color: #e5e7eb; /* Light text for dark background */
      box-sizing: border-box;
      padding: calc(env(safe-area-inset-top, 16px) + 16px) 16px calc(env(safe-area-inset-bottom, 16px) + 16px);
      overflow: auto;
      border-radius: 14px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.5);
    }

    /* Ensure buttons stretch nicely inside the overlay */
    .poll-overlay .row { display:flex; gap:8px; }
    .poll-overlay .row button { flex:1; }
    
    /* Selected vote button styling */
    .poll-overlay button.vote-selected {
      background: linear-gradient(180deg, rgba(96,165,250,.25), rgba(96,165,250,.15));
      border: 2px solid rgba(96,165,250,.8);
      box-shadow: 0 0 12px rgba(96,165,250,.4);
    }
    
    /* Gradients of Agreement button styles */
    .gradient-btn {
      width: 100%;
      padding: 12px 16px;
      text-align: left;
      border-radius: 8px;
      border: 2px solid rgba(255,255,255,.12);
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.95rem;
    }
    
    .gradient-btn:hover {
      transform: translateX(4px);
      border-color: rgba(255,255,255,.3);
    }
    
    .gradient-btn strong {
      display: block;
      margin-bottom: 4px;
    }
    
    .gradient-desc {
      font-size: 0.8rem;
      font-weight: normal;
      opacity: 0.8;
      font-style: italic;
    }
    
    .gradient-btn-green {
      background: linear-gradient(180deg, rgba(144,238,144,.25), rgba(144,238,144,.15));
    }
    
    .gradient-btn-blue {
      background: linear-gradient(180deg, rgba(173,216,230,.25), rgba(173,216,230,.15));
    }
    
    .gradient-btn-red {
      background: linear-gradient(180deg, rgba(255,182,193,.25), rgba(255,182,193,.15));
    }
    
    .gradient-btn.vote-selected {
      border: 2px solid rgba(96,165,250,.8);
      box-shadow: 0 0 12px rgba(96,165,250,.4);
    }
    
    /* Assume chair button positioning */
    .floating-assume-chair {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 8px;
      z-index: 100;
    }
    
    .header {
      position: relative;
    }
    
    /* Ensure consistent header element sizing and alignment */
    .header .pill, 
    .header .primary {
      height: auto;
      line-height: 1.2;
      font-size: 0.9rem;
      padding: 6px 12px;
    }
    
    .header h1 {
      font-size: 1.5rem;
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header class="header">
      <h1><a href="/landing.html" style="text-decoration: none; color: inherit;">SPEEK.NOW</a> - Participant</h1>
      <div class="room-code-display">
        <span class="muted small">Room Code:</span>
        <span id="roomCodeDisplay" class="room-code">----</span>
        <button id="btnShareParticipantUrlHeader" class="primary" style="padding: 6px 12px; border-radius: 8px; font-size: 1.1rem; margin-right: 8px;" aria-label="Share participation link"><i class="fa-solid fa-share-nodes"></i> Share</button>
      </div>
      <div id="conn" class="pill">Connecting…</div>
      <div id="chairStatus" class="pill">Chair: Checking…</div>
      <button id="btnAssumeChair" class="floating-assume-chair" style="display: none;"><i class="fa-solid fa-user"></i> Assume Chair</button>
    </header>

    <div id="assumeChairStatus" class="muted small assume-chair-status"></div>

    <main class="grid">
      <!-- Participant Controls -->
      <section class="card">
        <h2>Request to Speak</h2>
        <div class="row">
          <input id="name" placeholder="Your initials or name" maxlength="30"/>
        </div>
        <div class="row">
          <button id="btnRequest" class="primary"><i class="fa-solid fa-hand"></i> Request to Speak</button>
          <button id="btnWithdraw" class="ghost">Withdraw Request</button>
        </div>
        <div id="status" class="muted small">Enter your initials and click Request to Speak.</div>
      </section>

      <!-- Meeting Status -->
      <section class="card">
        <h2>Meeting Status</h2>

        <div class="two">
          <div>
            <div class="muted small">Current speaker</div>
            <div id="curName" class="big">--</div>
          </div>
          <div>
            <div class="muted small">Speaker time</div>
            <div id="speakTimer" class="timer ok">00:00</div>
            <div class="muted tiny" id="remaining">(remaining: 00:00)</div>
          </div>
          <div>
            <div class="muted small">Meeting time</div>
            <div id="meetingTimer" class="timer">00:00</div>
          </div>
        </div>

        <div class="muted small">Speaking Queue (<span id="qCount">0</span>)</div>
        <ul id="queue" class="list"></ul>
      </section>

      <!-- Room Info -->
      <section class="card">
        <h2>Room Information</h2>
        <div class="room-info">
          <div class="room-code-large">
            <div class="muted small">Room Code:</div>
            <div id="roomCodeLarge" class="room-code-big">----</div>
          </div>
          <div class="row">
            <button id="btnCopyCode" class="ghost"><i class="fa-solid fa-clipboard"></i> Copy Room Code</button>
            <button id="btnShareParticipantUrl" class="primary" aria-label="Share"><i class="fa-solid fa-share-nodes" style="margin-right: 8px;"></i> Share</button>
          </div>
          <div id="copyStatus" class="muted small"></div>
          
          <!-- Meeting Topic Display -->
          <div id="meetingTopicDisplay" style="margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 16px; display: none;">
            <div class="muted small" style="margin-bottom: 8px; font-weight: bold;">Meeting Topic:</div>
            <div id="meetingTopicText" style="font-size: 1rem; font-weight: 600; color: var(--text);"></div>
          </div>
          
          <!-- Configuration Display -->
          <div id="configDisplayParticipant" style="margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 16px; display: none;">
            <div class="muted small" style="margin-bottom: 12px; font-weight: bold;">Selected Options:</div>
            <div id="configDisplayTextParticipant" style="font-size: 0.85rem; line-height: 1.5;"></div>
          </div>
        </div>
        
      </section>

      <!-- Poll Section (always visible for participants) -->
      <section class="card" id="pollSection">
        <!-- Empty/default poll view shown when no active or previous poll exists -->
          <div id="pollEmpty">
            <h2>Poll View</h2>
            <div id="pollEmptyMsg" style="font-weight: bold; margin: 12px 0; font-size: 1.1rem;">Poll View - no active poll</div>
          </div>
        
          <!-- Poll results (shown in participant view when no active poll) -->
          <div id="pollResultsParticipant" style="display: none;">
          <h2>Last Poll Results</h2>
          <div id="pollResultsQuestionParticipant" style="font-weight: bold; margin: 8px 0;"></div>
          <div id="pollResultsDataParticipant" style="margin: 8px 0;"></div>
        </div>
      </section>
    </main>

    <footer>
      <div class="footer-links">
        <a href="legal.html">Imprint</a>
        <a href="https://github.com/Agh42/SpeakRequest" target="_blank" rel="noopener noreferrer">Source</a>
        <a href="legal.html">Legal / Data Privacy</a>
      </div>
    </footer>
  </div>

    <!-- Poll Overlay: shown only while poll is ACTIVE -->
    <div id="pollOverlay" class="poll-overlay" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="panel" id="pollOverlayPanel">
        <h2 id="overlayHeading">Active Poll</h2>
        <div id="overlayPollQuestionDisplay" style="font-weight: bold; margin: 12px 0; font-size: 1.1rem;"></div>
        
        <!-- Voting section (shown during ACTIVE state) -->
        <div id="overlayVotingSection">
          <!-- Yes/No voting (shown for YES_NO polls) -->
          <div id="yesNoVoting" style="display: none;">
            <div class="row" style="margin-bottom:12px;">
              <button id="overlayBtnVoteYes" class="primary"><i class="fa-solid fa-thumbs-up"></i> Yes</button>
              <button id="overlayBtnVoteNo" class="accent"><i class="fa-solid fa-thumbs-down"></i> No</button>
            </div>
          </div>
          
          <!-- Gradients voting (shown for GRADIENTS polls) -->
          <div id="gradientsVoting" style="display: none;">
            <button id="overlayBtnVoteOpt1" class="gradient-btn gradient-btn-green" style="margin: 6px 0;">
              <strong>1 Whole-hearted Endorsement</strong>
              <div class="gradient-desc">"I really like it"</div>
            </button>
            <button id="overlayBtnVoteOpt2" class="gradient-btn gradient-btn-green" style="margin: 6px 0;">
              <strong>2 Agreement with a Minor Point of Contention</strong>
              <div class="gradient-desc">"Not perfect, but it's good enough"</div>
            </button>
            <button id="overlayBtnVoteOpt3" class="gradient-btn gradient-btn-green" style="margin: 6px 0;">
              <strong>3 Support with Reservations</strong>
              <div class="gradient-desc">"I can live with it"</div>
            </button>
            <button id="overlayBtnVoteOpt4" class="gradient-btn gradient-btn-blue" style="margin: 6px 0;">
              <strong>4 Abstain</strong>
              <div class="gradient-desc">"This issue does not affect me"</div>
            </button>
            <button id="overlayBtnVoteOpt5" class="gradient-btn gradient-btn-red" style="margin: 6px 0;">
              <strong>5 More Discussion Needed</strong>
              <div class="gradient-desc">"I don't understand the issue well enough yet."</div>
            </button>
            <button id="overlayBtnVoteOpt6" class="gradient-btn gradient-btn-red" style="margin: 6px 0;">
              <strong>6 Don't Like But Will Support</strong>
              <div class="gradient-desc">"It's not great but I don't want to hold up the group."</div>
            </button>
            <button id="overlayBtnVoteOpt7" class="gradient-btn gradient-btn-red" style="margin: 6px 0;">
              <strong>7 Serious Disagreement</strong>
              <div class="gradient-desc">"I am not on board with this - don't count on me."</div>
            </button>
            <button id="overlayBtnVoteOpt8" class="gradient-btn gradient-btn-red" style="margin: 6px 0;">
              <strong>8 Veto</strong>
              <div class="gradient-desc">"I block this proposal"</div>
            </button>
            <div style="margin-top: 12px; font-size: 0.7rem; color: rgba(255,255,255,0.5); font-style: italic;">
              Reference: Kaner, S. (2014). Facilitator's Guide to Participatory Decision-Making. Third edition, Jossey-Bass: San Francisco, California, United States of America.
            </div>
          </div>
          
          <!-- Multiselect voting (shown for MULTISELECT polls) -->
          <div id="multiselectVoting" style="display: none;">
            <div id="multiselectOptionsDisplay"></div>
          </div>
          
          <div id="overlayVoteStatus" class="muted small" style="margin-top: 12px;"></div>
        </div>
        
        <!-- Results section (shown during ENDED state) -->
        <div id="overlayResultsSection" style="display: none;">
          <div style="font-weight: bold; margin: 12px 0;">Poll Results</div>
          <div id="overlayResultsData" style="margin: 8px 0;"></div>
          <div class="muted small" style="margin-top: 16px;">Waiting for chair to continue discussion...</div>
        </div>
      </div>
    </div>

  <script>
    // Extract room code from URL query parameter
    const urlParams = new URLSearchParams(window.location.search);
    const roomCode = urlParams.get('room');

    if (!roomCode || roomCode.length !== 4) {
      alert('Invalid room code. Redirecting to home page.');
      window.location.href = '/landing.html';
    }

    // Display room code
    document.getElementById('roomCodeDisplay').textContent = roomCode;
    document.getElementById('roomCodeLarge').textContent = roomCode;

    // --- Utilities ---
    const $ = sel => document.querySelector(sel);
    const fmt = ms => {
      const s = Math.max(0, Math.floor(ms/1000));
      const mm = String(Math.floor(s/60)).padStart(2,'0');
      const ss = String(s%60).padStart(2,'0');
      return `${mm}:${ss}`;
    };
    const setTimerClass = (el, warn, danger)=>{
      el.classList.remove('ok','warn','danger');
      if (danger) el.classList.add('danger'); else if (warn) el.classList.add('warn'); else el.classList.add('ok');
    };

    // --- DOM refs ---
    const elConn = $('#conn');
    const elChairStatus = $('#chairStatus');
    const elStatus = $('#status');
    const elQueue = $('#queue'); const elQCount = $('#qCount');
    const elCurName = $('#curName');
    const elSpeakTimer = $('#speakTimer'); const elRemaining = $('#remaining');
    const elMeeting = $('#meetingTimer');

    const elName = $('#name');
    const elBtnAssumeChair = $('#btnAssumeChair');
    const elAssumeChairStatus = $('#assumeChairStatus');
    
    // Meeting topic elements
    const elMeetingTopicDisplay = $('#meetingTopicDisplay');
    const elMeetingTopicText = $('#meetingTopicText');
    
    // Poll elements
  const elPollSection = $('#pollSection');
  const elPollEmpty = $('#pollEmpty');
  const elPollVoting = $('#pollVoting');
  const elPollResultsParticipant = $('#pollResultsParticipant');
  const elPollQuestionDisplay = $('#pollQuestionDisplay');
  const elPollResultsQuestionParticipant = $('#pollResultsQuestionParticipant');
  const elPollResultsDataParticipant = $('#pollResultsDataParticipant');
  const elVoteStatus = $('#voteStatus');
  
  // Configuration display elements
  const elConfigDisplayParticipant = $('#configDisplayParticipant');
  const elConfigDisplayTextParticipant = $('#configDisplayTextParticipant');

    // --- State ---
    let client = null;
    let meetingStart = 0;
    let timerInterval = null;
    let myName = '';
    let currentState = null; // Add this to store the full state
    let pendingChairRequestId = null; // Track our pending chair request
    let hasVoted = false; // Track if user has voted in current poll
    
    // Descriptions loaded from server
    let descriptions = {
      meetingGoal: {},
      participationFormat: {},
      decisionRule: {},
      deliverable: {}
    };

    // --- viewport workaround for mobile (--vh) ---
    function setVh() {
      document.documentElement.style.setProperty('--vh', `${window.innerHeight * 0.01}px`);
    }
    setVh();
    window.addEventListener('resize', setVh);
    window.addEventListener('orientationchange', setVh);

    // --- Overlay helpers ---
    const elPollOverlay = $('#pollOverlay');
    const elPollOverlayPanel = $('#pollOverlayPanel');
    const elOverlayQuestion = $('#overlayPollQuestionDisplay');
    const elOverlayVoteStatus = $('#overlayVoteStatus');
    const elOverlayBtnYes = $('#overlayBtnVoteYes');
    const elOverlayBtnNo = $('#overlayBtnVoteNo');
    const elOverlayVotingSection = $('#overlayVotingSection');
    const elOverlayResultsSection = $('#overlayResultsSection');
    const elOverlayResultsData = $('#overlayResultsData');
    
    // Gradients voting sections
    const elYesNoVoting = $('#yesNoVoting');
    const elGradientsVoting = $('#gradientsVoting');
    const elMultiselectVoting = $('#multiselectVoting');
    const elMultiselectOptionsDisplay = $('#multiselectOptionsDisplay');
    
    // Gradients voting buttons
    const elOverlayBtnOpt1 = $('#overlayBtnVoteOpt1');
    const elOverlayBtnOpt2 = $('#overlayBtnVoteOpt2');
    const elOverlayBtnOpt3 = $('#overlayBtnVoteOpt3');
    const elOverlayBtnOpt4 = $('#overlayBtnVoteOpt4');
    const elOverlayBtnOpt5 = $('#overlayBtnVoteOpt5');
    const elOverlayBtnOpt6 = $('#overlayBtnVoteOpt6');
    const elOverlayBtnOpt7 = $('#overlayBtnVoteOpt7');
    const elOverlayBtnOpt8 = $('#overlayBtnVoteOpt8');
    
    // Track current vote
    let currentVote = null; // 'YES', 'NO', 'OPT_1', ... 'OPT_8', or null (for single selection)
    let selectedVotes = new Set(); // Set of vote keys for multiple selection polls
    let currentPollType = null; // Track current poll type
    let maxVotesPerParticipant = 1; // Max votes for multiple selection

    function openOverlay() {
      // prevent background scroll
      document.documentElement.style.overflow = 'hidden';
      elPollOverlay.style.display = 'flex';
      elPollOverlay.setAttribute('aria-hidden', 'false');
      // focus management
      setTimeout(() => {
        const first = elPollOverlay.querySelector('button, [tabindex], input');
        if (first) first.focus();
      }, 50);
      // hide non-poll interactive controls from screen readers
      document.querySelector('main.grid').setAttribute('aria-hidden', 'true');
    }

    function closeOverlay() {
      document.documentElement.style.overflow = '';
      elPollOverlay.style.display = 'none';
      elPollOverlay.setAttribute('aria-hidden', 'true');
      document.querySelector('main.grid').removeAttribute('aria-hidden');
    }

    // --- WebSocket ---
    function connect() {
      const scheme = location.protocol === 'https:' ? 'wss' : 'ws';
      const sock = new WebSocket(`${scheme}://${location.host}/ws`);
      client = Stomp.over(sock);
      client.debug = () => {}; // silence debug

      client.connect({}, () => {
        elConn.textContent = 'Connected';
        elConn.classList.remove('warn');
        elConn.classList.add('ok');

        client.subscribe(`/topic/room/${roomCode}/state`, msg => {
          const state = JSON.parse(msg.body);
          updateUI(state);
        });

        client.subscribe(`/topic/room/${roomCode}/chairAssumed`, msg => {
          const response = JSON.parse(msg.body);
          if (response.success) {
            // Check if this response is for our request
            if (response.requestId === pendingChairRequestId) {
              elAssumeChairStatus.textContent = '✓ Chair role assumed! Redirecting...';
              elAssumeChairStatus.className = 'ok small';
              pendingChairRequestId = null; // Clear the pending request
              // Redirect to chair view
              setTimeout(() => {
                window.location.href = `/chair.html?room=${roomCode}`;
              }, 1000);
            }
          }
        });
        
        // Subscribe to room destroyed event
        client.subscribe(`/topic/room/${roomCode}/destroyed`, msg => {
          const data = JSON.parse(msg.body);
          alert(data.message + '\n\nClick OK to return to the landing page.');
          window.location.href = data.landingUrl;
        });
        
        // Subscribe to room error events
        client.subscribe(`/topic/room/${roomCode}/error`, msg => {
          const error = JSON.parse(msg.body);
          alert(error.error + '\n\nYou will be redirected to the landing page.');
          window.location.href = error.landingUrl;
        });

        // Join to get initial state
        client.send(`/app/room/${roomCode}/join`, {}, JSON.stringify({name:'Anonymous'}));
      }, () => {
        elConn.textContent = 'Disconnected';
        elConn.classList.remove('ok');
        elConn.classList.add('warn');
        setTimeout(connect, 2000);
      });
    }

    function updateUI(state) {
      meetingStart = state.meetingStartSec;
      currentState = state; // Store the current state

      // Update meeting topic
      if (state.roomConfig && state.roomConfig.topic) {
        elMeetingTopicDisplay.style.display = 'block';
        elMeetingTopicText.textContent = DOMPurify.sanitize(state.roomConfig.topic);
      } else {
        elMeetingTopicDisplay.style.display = 'none';
      }

      // Update chair status
      if (state.chairOccupied) {
        elChairStatus.textContent = 'Chair: Occupied';
        elChairStatus.classList.remove('warn');
        elChairStatus.classList.add('ok');
        elBtnAssumeChair.style.display = 'none';
      } else {
        elChairStatus.textContent = 'Chair: Vacant';
        elChairStatus.classList.remove('ok');
        elChairStatus.classList.add('warn');
        elBtnAssumeChair.style.display = 'block';
      }

      // Queue
      elQCount.textContent = state.queue.length;
      elQueue.innerHTML = '';
      let myPosition = -1;
      state.queue.forEach((p, i) => {
        const li = document.createElement('li');
        li.innerHTML = `<span class="name">${DOMPurify.sanitize(p.name)}</span>`;

        // Highlight my entry
        if (p.name.toLowerCase() === myName.toLowerCase()) {
          li.style.backgroundColor = '#8991c7';
          li.style.fontWeight = 'bold';
          myPosition = i + 1;
        }

        elQueue.appendChild(li);
      });

      // Update status based on my position
      if (myName) {
        if (state.current && state.current.entry.name.toLowerCase() === myName.toLowerCase()) {
          elStatus.textContent = `You are currently speaking!`;
          elStatus.className = 'ok small';
        } else if (myPosition > 0) {
          elStatus.textContent = `You are #${myPosition} in the queue`;
          elStatus.className = 'muted small';
        } else {
          elStatus.textContent = `Joined as ${myName}`;
          elStatus.className = 'muted small';
        }
      }

      // Current speaker
      if (state.current) {
        const c = state.current;
        elCurName.textContent = DOMPurify.sanitize(c.entry.name);
      } else {
        elCurName.textContent = '--';
      }

      updateTimers(state);
      updatePollUIParticipant(state);
      updateConfigDisplayParticipant(state);
    }
    
    function updateConfigDisplayParticipant(state) {
      if (state.roomConfig) {
        const config = state.roomConfig;
        let html = '';
        let hasAnySelection = false;
        
        if (config.participationFormat) {
          hasAnySelection = true;
          const formatMap = {
            'STRUCTURED_GO_AROUNDS': 'Structured Go-Arounds',
            'PRESENTATIONS_AND_REPORTS': 'Presentations and Reports',
            'SMALL_GROUPS': 'Small Groups',
            'LISTING_IDEAS': 'Listing Ideas',
            'JIGSAW': 'Jigsaw',
            'INDIVIDUAL_WRITING': 'Individual Writing',
            'MULTI_TASKING': 'Multi-Tasking',
            'OPEN_DISCUSSION': 'Open Discussion',
            'FISHBOWLS': 'Fishbowls',
            'TRADESHOW': 'Tradeshow',
            'SCRAMBLER': 'Scrambler',
            'ROLEPLAYS': 'Roleplays'
          };
          const optionText = formatMap[config.participationFormat] || config.participationFormat;
          const desc = descriptions.participationFormat[config.participationFormat]?.description || 'NOT FOUND';
          html += `<div style="margin-bottom: 8px;"><strong>Participation Format:</strong> ${optionText}<br/><span style="color: rgba(255,255,255,0.7);">${desc}</span></div>`;
        }
        
        if (config.meetingGoal) {
          hasAnySelection = true;
          const goalMap = {
            'SHARE_INFORMATION': 'Share Information',
            'ADVANCE_THINKING': 'Advance the Thinking',
            'OBTAIN_INPUT': 'Obtain Input',
            'MAKE_DECISIONS': 'Make Decisions',
            'IMPROVE_COMMUNICATION': 'Improve Communication',
            'BUILD_CAPACITY': 'Build Capacity',
            'BUILD_COMMUNITY': 'Build Community'
          };
          const optionText = goalMap[config.meetingGoal] || config.meetingGoal;
          const desc = descriptions.meetingGoal[config.meetingGoal]?.description || 'NOT FOUND';
          html += `<div style="margin-bottom: 8px;"><strong>Meeting Goal:</strong> ${optionText}<br/><span style="color: rgba(255,255,255,0.7);">${desc}</span></div>`;
        }
        
        if (config.decisionRule) {
          hasAnySelection = true;
          const ruleMap = {
            'UNANIMITY': 'Unanimity',
            'GRADIENTS_OF_AGREEMENT': 'Gradients of Agreement',
            'DOT_VOTING': 'Dot Voting',
            'SUPERMAJORITY': 'Supermajority',
            'MAJORITY': 'Majority',
            'PLURALITY': 'Plurality',
            'CONSENT': 'Consent',
            'PERSON_IN_CHARGE': 'Person in Charge',
            'COMMISSION': 'Commission',
            'FLIP_A_COIN': 'Flip a Coin'
          };
          const optionText = ruleMap[config.decisionRule] || config.decisionRule;
          const desc = descriptions.decisionRule[config.decisionRule]?.description || 'NOT FOUND';
          html += `<div style="margin-bottom: 8px;"><strong>Decision Rule:</strong> ${optionText}<br/><span style="color: rgba(255,255,255,0.7);">${desc}</span></div>`;
        }
        
        if (config.deliverable) {
          hasAnySelection = true;
          const deliverableMap = {
            'DEFINE_PROBLEM': 'Define a problem',
            'CREATE_MILESTONE_MAP': 'Create a milestone map',
            'ANALYZE_PROBLEM': 'Analyze a problem',
            'CREATE_WORK_BREAKDOWN': 'Create a work breakdown structure',
            'IDENTIFY_ROOT_CAUSES': 'Identify root causes',
            'CONDUCT_RESOURCE_ANALYSIS': 'Conduct a resource analysis',
            'IDENTIFY_PATTERNS': 'Identify underlying patterns',
            'CONDUCT_RISK_ASSESSMENT': 'Conduct a risk assessment',
            'SORT_IDEAS_INTO_THEMES': 'Sort a list of ideas into themes',
            'DEFINE_SELECTION_CRITERIA': 'Define selection criteria',
            'REARRANGE_BY_PRIORITY': 'Rearrange a list of items by priority',
            'EVALUATE_OPTIONS': 'Evaluate options',
            'DRAW_FLOWCHART': 'Draw a flowchart',
            'IDENTIFY_SUCCESS_FACTORS': 'Identify critical success factors',
            'IDENTIFY_CORE_VALUES': 'Identify core values',
            'EDIT_STATEMENT': 'Edit and/or wordsmith a statement'
          };
          const optionText = deliverableMap[config.deliverable] || config.deliverable;
          const desc = descriptions.deliverable[config.deliverable]?.description || 'NOT FOUND';
          html += `<div style="margin-bottom: 8px;"><strong>Deliverable:</strong> ${optionText}<br/><span style="color: rgba(255,255,255,0.7);">${desc}</span></div>`;
        }
        
        if (hasAnySelection) {
          elConfigDisplayTextParticipant.innerHTML = html;
          elConfigDisplayParticipant.style.display = 'block';
        } else {
          elConfigDisplayParticipant.style.display = 'none';
        }
      } else {
        elConfigDisplayParticipant.style.display = 'none';
      }
    }
    
    function updatePollUIParticipant(state) {
      const pollState = state.pollState;
      
      // Show poll section always (participants should always see poll box)
      // Manage views: empty (default), overlay (active), results (ended)
      elPollEmpty.style.display = 'block';
      elPollResultsParticipant.style.display = 'none';
      closeOverlay();

      if (!pollState || (!pollState.status && !pollState.lastResults)) {
        // No active poll and no last results -> show empty message
        elPollEmpty.style.display = 'block';
        // Ensure normal controls enabled
        $('#btnRequest').disabled = false;
        $('#btnWithdraw').disabled = false;
        // Reset vote tracking
        currentVote = null;
        currentPollType = null;
        selectedVotes.clear();
        maxVotesPerParticipant = 1;
        return;
      }

      // If poll is ACTIVE, open overlay and disable background controls
      if (pollState.status === 'ACTIVE') {
        elPollEmpty.style.display = 'none';
        currentPollType = pollState.pollType;
        
        // Show overlay with voting section
        elOverlayQuestion.textContent = DOMPurify.sanitize(pollState.question);
        elOverlayVotingSection.style.display = 'block';
        elOverlayResultsSection.style.display = 'none';
        
        // Set poll type and voting parameters
        currentPollType = pollState.pollType;
        maxVotesPerParticipant = pollState.votesPerParticipant || 1;
        
        // Show appropriate voting UI based on poll type
        if (pollState.pollType === 'GRADIENTS') {
          elYesNoVoting.style.display = 'none';
          elGradientsVoting.style.display = 'block';
          elMultiselectVoting.style.display = 'none';
        } else if (pollState.pollType === 'MULTISELECT' || pollState.pollType === 'MULTISELECT_MULTIPLE') {
          elYesNoVoting.style.display = 'none';
          elGradientsVoting.style.display = 'none';
          elMultiselectVoting.style.display = 'block';
          renderMultiselectVotingOptions(pollState.options);
        } else {
          elYesNoVoting.style.display = 'block';
          elGradientsVoting.style.display = 'none';
          elMultiselectVoting.style.display = 'none';
        }
        
        // Update vote status message based on current vote
        if (pollState.pollType === 'MULTISELECT_MULTIPLE') {
          updateMultipleSelectionStatus();
        } else if (currentVote) {
          elOverlayVoteStatus.textContent = `✓ You voted: ${getVoteLabel(currentVote, pollState.pollType, pollState)}`;
          elOverlayVoteStatus.className = 'ok small';
        } else {
          elOverlayVoteStatus.textContent = 'Cast your vote (you can change it):';
          elOverlayVoteStatus.className = 'muted small';
        }
        
        // Update button styling based on selection
        updateVoteButtonStyles();
        
        // Disable background controls
        $('#btnRequest').disabled = true;
        $('#btnWithdraw').disabled = true;
        openOverlay();
        return;
      }

      // If poll is ENDED, show results in overlay
      if (pollState.status === 'ENDED') {
        elPollEmpty.style.display = 'none';
        // Show overlay with results section
        elOverlayQuestion.textContent = DOMPurify.sanitize(pollState.question);
        elOverlayVotingSection.style.display = 'none';
        elOverlayResultsSection.style.display = 'block';
        
        // Format results based on poll type
        let resultsHTML = '<div style="margin-top: 8px;">';
        
        if (pollState.pollType === 'GRADIENTS') {
          resultsHTML += renderGradientsResults(pollState.results, pollState.totalVotes);
        } else if (pollState.pollType === 'MULTISELECT' || pollState.pollType === 'MULTISELECT_MULTIPLE') {
          resultsHTML += renderMultiselectResults(pollState.results, pollState.totalVotes, pollState.options);
        } else if (pollState.pollType === 'YES_NO') {
          // Yes/No results as bar chart
          resultsHTML += renderYesNoResults(pollState.results, pollState.totalVotes);
        } else {
          // Fallback for any other poll types
          for (const [option, count] of Object.entries(pollState.results)) {
            const percentage = pollState.totalVotes > 0 ? Math.round((count / pollState.totalVotes) * 100) : 0;
            resultsHTML += `<div style="margin: 4px 0;"><strong>${option}:</strong> ${count} (${percentage}%)</div>`;
          }
        }
        
        resultsHTML += `<div style="margin-top: 8px;" class="muted small">Total votes: ${pollState.totalVotes}</div>`;
        resultsHTML += '</div>';
        elOverlayResultsData.innerHTML = resultsHTML;
        
        // Keep background controls disabled
        $('#btnRequest').disabled = true;
        $('#btnWithdraw').disabled = true;
        openOverlay();
        return;
      }

      // If poll is CLOSED or we have lastResults, show in participant view box and close overlay
      if (pollState.status === 'CLOSED' || pollState.lastResults) {
        elPollEmpty.style.display = 'none';
        elPollResultsParticipant.style.display = 'block';
        closeOverlay();
        
        // Re-enable controls
        $('#btnRequest').disabled = false;
        $('#btnWithdraw').disabled = false;
        
        // Reset vote tracking for next poll
        currentVote = null;
        currentPollType = null;
        selectedVotes.clear();
        maxVotesPerParticipant = 1;

        const results = pollState.lastResults;
        elPollResultsQuestionParticipant.textContent = DOMPurify.sanitize(results.question);

        let resultsHTML = '<div style="margin-top: 8px;">';
        
        // Check pollType in lastResults if available, otherwise infer from keys
        if (results.pollType === 'MULTISELECT' || results.pollType === 'MULTISELECT_MULTIPLE' || (results.options && results.options.length > 0)) {
          resultsHTML += renderMultiselectResults(results.results, results.totalVotes, results.options);
        } else if (results.pollType === 'GRADIENTS' || Object.keys(results.results).some(k => k.startsWith('OPT_'))) {
          resultsHTML += renderGradientsResults(results.results, results.totalVotes);
        } else if (results.pollType === 'YES_NO') {
          resultsHTML += renderYesNoResults(results.results, results.totalVotes);
        } else {
          // Fallback for any other poll types
          for (const [option, count] of Object.entries(results.results)) {
            const percentage = results.totalVotes > 0 ? Math.round((count / results.totalVotes) * 100) : 0;
            resultsHTML += `<div style="margin: 4px 0;"><strong>${option}:</strong> ${count} (${percentage}%)</div>`;
          }
        }
        
        resultsHTML += `<div style="margin-top: 8px;" class="muted small">Total votes: ${results.totalVotes}</div>`;
        resultsHTML += '</div>';
        elPollResultsDataParticipant.innerHTML = resultsHTML;
        return;
      }
    }
    
    function getVoteLabel(vote, pollType, pollState = null) {
      if (pollType === 'GRADIENTS') {
        const labels = {
          'OPT_1': '1 - Whole-hearted Endorsement',
          'OPT_2': '2 - Agreement with Minor Point of Contention',
          'OPT_3': '3 - Support with Reservations',
          'OPT_4': '4 - Abstain',
          'OPT_5': '5 - More Discussion Needed',
          'OPT_6': '6 - Don\'t Like But Will Support',
          'OPT_7': '7 - Serious Disagreement',
          'OPT_8': '8 - Veto'
        };
        return labels[vote] || vote;
      } else if (pollType === 'MULTISELECT' && pollState && pollState.options) {
        // Extract option index from vote key (e.g., 'OPT_0' -> 0)
        const match = vote.match(/^OPT_(\d+)$/);
        if (match) {
          const index = parseInt(match[1]);
          return pollState.options[index] || vote;
        }
      }
      return vote === 'YES' ? 'Yes' : 'No';
    }
    
    function renderGradientsResults(results, totalVotes) {
      const gradientOptions = [
        { key: 'OPT_1', num: '1', label: 'Whole-hearted Endorsement' },
        { key: 'OPT_2', num: '2', label: 'Agreement with Minor Point of Contention' },
        { key: 'OPT_3', num: '3', label: 'Support with Reservations' },
        { key: 'OPT_4', num: '4', label: 'Abstain' },
        { key: 'OPT_5', num: '5', label: 'More Discussion Needed' },
        { key: 'OPT_6', num: '6', label: 'Don\'t Like But Will Support' },
        { key: 'OPT_7', num: '7', label: 'Serious Disagreement' },
        { key: 'OPT_8', num: '8', label: 'Veto' }
      ];
      
      let html = '<div style="margin: 16px 0; font-size: 0.75rem;">';
      html += '<div style="display: flex; align-items: flex-end; justify-content: space-between; height: 120px; margin-bottom: 8px;">';
      
      // Create bars for each option
      gradientOptions.forEach(opt => {
        const count = results[opt.key] || 0;
        const maxBarHeight = 120; // Match the container height
        const heightPx = totalVotes > 0 ? Math.max((count / totalVotes) * maxBarHeight, count > 0 ? 4 : 0) : 0;
        
        html += `<div style="flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; position: relative;">`;
        // Count above bar
        if (count > 0) {
          html += `<div style="font-weight: bold; font-size: 0.7rem; color: rgba(96,165,250,1); margin-bottom: 2px;">${count}</div>`;
        }
        // Bar
        html += `<div style="background: rgba(96,165,250,0.6); width: 80%; height: ${heightPx}px; border-radius: 4px 4px 0 0;"></div>`;
        html += `</div>`;
      });
      
      html += '</div>';
      
      // Number line with wrapped labels
      html += '<div style="display: flex; justify-content: space-between; border-top: 2px solid rgba(255,255,255,0.3); padding-top: 8px;">';
      
      gradientOptions.forEach(opt => {
        html += `<div style="flex: 1; display: flex; flex-direction: column; align-items: center; min-height: 100px; padding: 0 2px;">`;
        html += `<div style="font-weight: bold; font-size: 0.85rem; margin-bottom: 6px;">${opt.num}</div>`;
        // Wrapped label
        html += `<div style="font-size: 0.5rem; text-align: center; line-height: 1.2; word-wrap: break-word; overflow-wrap: break-word; hyphens: auto; max-width: 100%;">${opt.label}</div>`;
        html += `</div>`;
      });
      
      html += '</div>';
      html += '<div style="margin-top: 8px; font-size: 0.45rem; color: rgba(255,255,255,0.5); font-style: italic;">Reference: Kaner, S. (2014). Facilitator\'s Guide to Participatory Decision-Making. Third edition, Jossey-Bass: San Francisco, California, United States of America.</div>';
      html += '</div>';
      
      return html;
    }
    
    function renderMultiselectVotingOptions(options) {
      if (!options || options.length === 0) return;
      
      elMultiselectOptionsDisplay.innerHTML = '';
      
      options.forEach((optionLabel, index) => {
        const btn = document.createElement('button');
        btn.className = 'gradient-btn';
        btn.style.margin = '6px 0';
        btn.innerHTML = `<strong>${DOMPurify.sanitize(optionLabel)}</strong>`;
        btn.dataset.optionKey = `OPT_${index}`;
        btn.dataset.optionLabel = optionLabel;
        
        btn.onclick = () => {
          const optionKey = btn.dataset.optionKey;
          
          if (currentPollType === 'MULTISELECT_MULTIPLE') {
            // Handle multiple selection with toggle
            if (selectedVotes.has(optionKey)) {
              // Deselect the option
              selectedVotes.delete(optionKey);
              client?.send(`/app/room/${roomCode}/poll/vote`, {}, JSON.stringify({vote: optionKey}));
              updateMultipleSelectionStatus();
            } else {
              // Check if max votes reached
              if (selectedVotes.size >= maxVotesPerParticipant) {
                elOverlayVoteStatus.textContent = `Maximum ${maxVotesPerParticipant} vote(s) reached. Deselect an option first.`;
                elOverlayVoteStatus.className = 'warn small';
                return;
              }
              // Select the option
              selectedVotes.add(optionKey);
              client?.send(`/app/room/${roomCode}/poll/vote`, {}, JSON.stringify({vote: optionKey}));
              updateMultipleSelectionStatus();
            }
            updateVoteButtonStyles();
          } else {
            // Handle single selection (original behavior)
            currentVote = optionKey;
            client?.send(`/app/room/${roomCode}/poll/vote`, {}, JSON.stringify({vote: optionKey}));
            elOverlayVoteStatus.textContent = `✓ You voted: ${DOMPurify.sanitize(optionLabel)}`;
            elOverlayVoteStatus.className = 'ok small';
            updateVoteButtonStyles();
          }
        };
        
        elMultiselectOptionsDisplay.appendChild(btn);
      });
      
      // Update button styles based on current votes
      updateVoteButtonStyles();
    }
    
    function updateMultipleSelectionStatus() {
      if (selectedVotes.size === 0) {
        elOverlayVoteStatus.textContent = `Select up to ${maxVotesPerParticipant} option(s)`;
        elOverlayVoteStatus.className = 'muted small';
      } else if (selectedVotes.size === maxVotesPerParticipant) {
        elOverlayVoteStatus.textContent = `✓ You selected ${selectedVotes.size} of ${maxVotesPerParticipant} option(s) (max reached)`;
        elOverlayVoteStatus.className = 'ok small';
      } else {
        elOverlayVoteStatus.textContent = `✓ You selected ${selectedVotes.size} of ${maxVotesPerParticipant} option(s)`;
        elOverlayVoteStatus.className = 'ok small';
      }
    }
    
    function renderMultiselectResults(results, totalVotes, options) {
      if (!options || options.length === 0) return '';
      
      let html = '<div style="margin: 16px 0;">';
      
      // Create horizontal bars for each option
      options.forEach((optionLabel, index) => {
        const optionKey = `OPT_${index}`;
        const count = results[optionKey] || 0;
        const percentage = totalVotes > 0 ? Math.round((count / totalVotes) * 100) : 0;
        const widthPercent = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
        
        html += `<div style="margin: 12px 0;">`;
        // Option label
        html += `<div style="font-weight: bold; margin-bottom: 4px; font-size: 0.95rem;">${DOMPurify.sanitize(optionLabel)}</div>`;
        // Bar container
        html += `<div style="display: flex; align-items: center; gap: 8px;">`;
        // Bar
        html += `<div style="flex: 1; background: rgba(255,255,255,0.1); border-radius: 4px; height: 24px; position: relative; overflow: hidden;">`;
        html += `<div style="background: rgba(96,165,250,0.6); width: ${widthPercent}%; height: 100%; border-radius: 4px; transition: width 0.3s ease;"></div>`;
        html += `</div>`;
        // Count and percentage
        html += `<div style="min-width: 80px; text-align: right; font-weight: bold; font-size: 0.9rem;">${count} (${percentage}%)</div>`;
        html += `</div>`;
        html += `</div>`;
      });
      
      html += '</div>';
      
      return html;
    }
    
    function renderYesNoResults(results, totalVotes) {
      const yesNoOptions = [
        { key: 'YES', label: 'Yes' },
        { key: 'NO', label: 'No' }
      ];
      
      let html = '<div style="margin: 16px 0;">';
      
      // Create horizontal bars for Yes/No
      yesNoOptions.forEach(opt => {
        const count = results[opt.key] || 0;
        const percentage = totalVotes > 0 ? Math.round((count / totalVotes) * 100) : 0;
        const widthPercent = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
        
        html += `<div style="margin: 12px 0;">`;
        // Option label
        html += `<div style="font-weight: bold; margin-bottom: 4px; font-size: 0.95rem;">${opt.label}</div>`;
        // Bar container
        html += `<div style="display: flex; align-items: center; gap: 8px;">`;
        // Bar
        html += `<div style="flex: 1; background: rgba(255,255,255,0.1); border-radius: 4px; height: 24px; position: relative; overflow: hidden;">`;
        html += `<div style="background: rgba(96,165,250,0.6); width: ${widthPercent}%; height: 100%; border-radius: 4px; transition: width 0.3s ease;"></div>`;
        html += `</div>`;
        // Count and percentage
        html += `<div style="min-width: 80px; text-align: right; font-weight: bold; font-size: 0.9rem;">${count} (${percentage}%)</div>`;
        html += `</div>`;
        html += `</div>`;
      });
      
      html += '</div>';
      
      return html;
    }
    
    function updateVoteButtonStyles() {
      if (currentPollType === 'MULTISELECT') {
        // Single selection - Remove selected class from all multiselect buttons
        const buttons = elMultiselectOptionsDisplay.querySelectorAll('button');
        buttons.forEach(btn => btn.classList.remove('vote-selected'));
        
        // Add selected class to the button that was voted for
        if (currentVote) {
          const selectedBtn = elMultiselectOptionsDisplay.querySelector(`button[data-option-key="${currentVote}"]`);
          if (selectedBtn) {
            selectedBtn.classList.add('vote-selected');
          }
        }
      } else if (currentPollType === 'MULTISELECT_MULTIPLE') {
        // Multiple selection - Remove selected class from all multiselect buttons
        const buttons = elMultiselectOptionsDisplay.querySelectorAll('button');
        buttons.forEach(btn => btn.classList.remove('vote-selected'));
        
        // Add selected class to all buttons that were voted for
        selectedVotes.forEach(voteKey => {
          const selectedBtn = elMultiselectOptionsDisplay.querySelector(`button[data-option-key="${voteKey}"]`);
          if (selectedBtn) {
            selectedBtn.classList.add('vote-selected');
          }
        });
      } else if (currentPollType === 'GRADIENTS') {
        // Remove selected class from all gradient buttons
        [elOverlayBtnOpt1, elOverlayBtnOpt2, elOverlayBtnOpt3, elOverlayBtnOpt4,
         elOverlayBtnOpt5, elOverlayBtnOpt6, elOverlayBtnOpt7, elOverlayBtnOpt8].forEach(btn => {
          btn.classList.remove('vote-selected');
        });
        
        // Add selected class to the button that was voted for
        const optionMap = {
          'OPT_1': elOverlayBtnOpt1,
          'OPT_2': elOverlayBtnOpt2,
          'OPT_3': elOverlayBtnOpt3,
          'OPT_4': elOverlayBtnOpt4,
          'OPT_5': elOverlayBtnOpt5,
          'OPT_6': elOverlayBtnOpt6,
          'OPT_7': elOverlayBtnOpt7,
          'OPT_8': elOverlayBtnOpt8
        };
        
        if (currentVote && optionMap[currentVote]) {
          optionMap[currentVote].classList.add('vote-selected');
        }
      } else {
        // Remove selected class from both Yes/No buttons
        elOverlayBtnYes.classList.remove('vote-selected');
        elOverlayBtnNo.classList.remove('vote-selected');
        
        // Add selected class to the button that was voted for
        if (currentVote === 'YES') {
          elOverlayBtnYes.classList.add('vote-selected');
        } else if (currentVote === 'NO') {
          elOverlayBtnNo.classList.add('vote-selected');
        }
      }
    }

    function updateTimers(state) {
      const nowSec = Math.floor(Date.now() / 1000);

      // Meeting timer
      const meetingMs = (nowSec - meetingStart) * 1000;
      elMeeting.textContent = fmt(meetingMs);

      // Speaker timer
      if (state.current) {
        const c = state.current;
        let elapsedMs = c.elapsedMs;
        if (c.running) {
          elapsedMs += (nowSec - c.startedAtSec) * 1000;
        }
        elSpeakTimer.textContent = fmt(elapsedMs);

        const remainingMs = Math.max(0, (c.limitSec * 1000) - elapsedMs);
        elRemaining.textContent = `(remaining: ${fmt(remainingMs)})`;

        const warnThreshold = c.limitSec * 1000 * 0.8;
        const dangerThreshold = c.limitSec * 1000 * 0.95;
        setTimerClass(elSpeakTimer, elapsedMs > warnThreshold, elapsedMs > dangerThreshold);
      } else {
        elSpeakTimer.textContent = '00:00';
        elRemaining.textContent = '(remaining: 00:00)';
        setTimerClass(elSpeakTimer, false, false);
      }
    }

    // --- Event handlers ---
    $('#btnRequest').onclick = () => {
      const name = elName.value.trim();
      if (!name) {
        elStatus.textContent = 'Please enter your name first';
        elStatus.className = 'warn small';
        return;
      }
      myName = name;
      client?.send(`/app/room/${roomCode}/request`, {}, JSON.stringify({name}));
    };

    $('#btnWithdraw').onclick = () => {
      const name = elName.value.trim();
      if (!name) {
        elStatus.textContent = 'Please enter your name first';
        elStatus.className = 'warn small';
        return;
      }
      client?.send(`/app/room/${roomCode}/withdraw`, {}, JSON.stringify({name}));
    };

    // Enter key handler for name input
    elName.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const name = elName.value.trim();
        if (!name) {
          elStatus.textContent = 'Please enter your name first';
          elStatus.className = 'warn small';
          return;
        }
        
        // Check if participant is already in queue, if so withdraw, otherwise request
        const inQueue = currentState && currentState.queue.some(p => p.name.toLowerCase() === name.toLowerCase());
        if (inQueue) {
          $('#btnWithdraw').click();
        } else {
          $('#btnRequest').click();
        }
      }
    });

    // Select all text when clicking in the input
    elName.addEventListener('click', () => {
      elName.select();
    });

    // Select all text when input gains focus
    elName.addEventListener('focus', () => {
      elName.select();
    });

    // Copy room code
    $('#btnCopyCode').onclick = async () => {
      try {
        await navigator.clipboard.writeText(roomCode);
        $('#copyStatus').textContent = 'Room code copied to clipboard!';
        setTimeout(() => $('#copyStatus').textContent = '', 3000);
      } catch (err) {
        $('#copyStatus').textContent = 'Could not copy to clipboard';
      }
    };

    // Assume chair role
    elBtnAssumeChair.onclick = () => {
      if (!client) {
        elAssumeChairStatus.textContent = 'Not connected to server';
        elAssumeChairStatus.className = 'warn small';
        return;
      }
      
      const participantName = myName || 'Participant';
      const requestId = Math.random().toString(36).substr(2, 9); // Generate unique request ID
      pendingChairRequestId = requestId; // Store it for later comparison
      
      client.send(`/app/room/${roomCode}/assumeChair`, {}, JSON.stringify({participantName, requestId}));
      elAssumeChairStatus.textContent = 'Requesting chair role...';
      elAssumeChairStatus.className = 'muted small';
      
      // Clear the pending request after 5 seconds if no response
      setTimeout(() => {
        if (pendingChairRequestId === requestId) {
          pendingChairRequestId = null;
          elAssumeChairStatus.textContent = '';
        }
      }, 5000);
    };

    // Load name from localStorage
    const savedName = localStorage.getItem('speakRequestName');
    if (savedName) {
      elName.value = savedName;
    }

    // Save name to localStorage when changed
    elName.onchange = () => {
      localStorage.setItem('speakRequestName', elName.value);
    };

    // Overlay poll vote handlers
    elOverlayBtnYes.onclick = () => {
      currentVote = 'YES';
      client?.send(`/app/room/${roomCode}/poll/vote`, {}, JSON.stringify({vote: 'YES'}));
      elOverlayVoteStatus.textContent = '✓ You voted: Yes';
      elOverlayVoteStatus.className = 'ok small';
      updateVoteButtonStyles();
    };

    elOverlayBtnNo.onclick = () => {
      currentVote = 'NO';
      client?.send(`/app/room/${roomCode}/poll/vote`, {}, JSON.stringify({vote: 'NO'}));
      elOverlayVoteStatus.textContent = '✓ You voted: No';
      elOverlayVoteStatus.className = 'ok small';
      updateVoteButtonStyles();
    };
    
    // Gradients vote handlers
    function createGradientsVoteHandler(optionKey, optionLabel) {
      return () => {
        currentVote = optionKey;
        client?.send(`/app/room/${roomCode}/poll/vote`, {}, JSON.stringify({vote: optionKey}));
        elOverlayVoteStatus.textContent = `✓ You voted: ${optionLabel}`;
        elOverlayVoteStatus.className = 'ok small';
        updateVoteButtonStyles();
      };
    }
    
    elOverlayBtnOpt1.onclick = createGradientsVoteHandler('OPT_1', '1 - Whole-hearted Endorsement');
    elOverlayBtnOpt2.onclick = createGradientsVoteHandler('OPT_2', '2 - Agreement with Minor Point of Contention');
    elOverlayBtnOpt3.onclick = createGradientsVoteHandler('OPT_3', '3 - Support with Reservations');
    elOverlayBtnOpt4.onclick = createGradientsVoteHandler('OPT_4', '4 - Abstain');
    elOverlayBtnOpt5.onclick = createGradientsVoteHandler('OPT_5', '5 - More Discussion Needed');
    elOverlayBtnOpt6.onclick = createGradientsVoteHandler('OPT_6', '6 - Don\'t Like But Will Support');
    elOverlayBtnOpt7.onclick = createGradientsVoteHandler('OPT_7', '7 - Serious Disagreement');
    elOverlayBtnOpt8.onclick = createGradientsVoteHandler('OPT_8', '8 - Veto');

    // --- Start ---
    // Load metadata first, then connect
    MetadataLoader.loadAll().then(metadata => {
      descriptions = metadata;
      connect();
      timerInterval = setInterval(() => {
        if (currentState) {
          updateTimers(currentState);
        }
      }, 250);
    }).catch(err => {
      console.error('Failed to load metadata, continuing anyway:', err);
      // Connect anyway with fallback values
      connect();
      timerInterval = setInterval(() => {
        if (currentState) {
          updateTimers(currentState);
        }
      }, 250);
    });

    // Initialize share button
    const shareParticipantBtn = $('#btnShareParticipantUrl');
    if (shareParticipantBtn) {
      ShareButton.init(shareParticipantBtn, {
        shareUrl: `${window.location.origin}/room/${roomCode}`,
        title: 'Join Meeting on SPEEK.NOW',
        text: `Join the meeting with room code ${roomCode}:`
      });
    }

    // Initialize share button in header
    const shareParticipantBtnHeader = $('#btnShareParticipantUrlHeader');
    if (shareParticipantBtnHeader) {
      ShareButton.init(shareParticipantBtnHeader, {
        shareUrl: `${window.location.origin}/room/${roomCode}`,
        title: 'Join Meeting on SPEEK.NOW',
        text: `Join the meeting with room code ${roomCode}:`
      });
    }
  </script>
</body>
</html>
