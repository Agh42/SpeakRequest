<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Speaker Display - SPEEK.NOW</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    :root{
      --bg:#0f172a; --card:#0b1221; --text:#e5e7eb; --muted:#94a3b8;
      --accent:#60a5fa; --ok:#10b981; --warn:#f59e0b; --danger:#ef4444;
      --border: rgba(255,255,255,.12);
    }
    *{box-sizing:border-box}
    html,body{height:100%; overflow:hidden;}
    body{
      margin:0; background:#0f172a;
      color:var(--text); font:16px/1.4 system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif;
      padding:20px;
      display: flex;
      flex-direction: column;
    }
    .content-container {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      /* Reserve space for QR code: 150px QR + 24px padding + 20px bottom margin = 194px */
      /* Also add some extra margin on the right to avoid QR code */
      padding-bottom: 20px;
      padding-right: 15px;
      margin-bottom: 194px;
    }
    .content-container::-webkit-scrollbar {
      width: 10px;
    }
    .content-container::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.05);
      border-radius: 5px;
    }
    .content-container::-webkit-scrollbar-thumb {
      background: var(--accent);
      border-radius: 5px;
    }
    .content-container::-webkit-scrollbar-thumb:hover {
      background: #4a90e2;
    }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0));
      border:1px solid var(--border); border-radius:14px; padding:20px; margin-bottom:20px;
    }
    .big{font-weight:800;font-size:2.4rem; margin-bottom:10px;}
    .medium{font-weight:700;font-size:1.6rem; margin-bottom:8px;}
    .small{font-size:1rem; margin-bottom:15px;}
    .muted{color:var(--muted)}
    .timer{font-variant-numeric:tabular-nums;font-weight:800;font-size:2.4rem}
    .timer.ok{color:#bbf7d0}.timer.warn{color:#fde68a}.timer.danger{color:#fecaca}
    .status{color:var(--accent); font-weight:600;}
    .conn-status{position:fixed;top:10px;right:10px;background:#0c1324;border:1px solid var(--border);padding:.35rem .7rem;border-radius:999px;color:var(--muted);font-size:0.8rem;}
    .conn-status.ok{color:#bbf7d0;border-color:rgba(16,185,129,.6)}
    .room-code{position:fixed;top:10px;left:10px;background:#0c1324;border:1px solid var(--border);padding:.35rem .7rem;border-radius:999px;color:var(--accent);font-size:0.8rem;font-weight:bold;}
    .join-instructions{position:fixed;top:40px;left:10px;right:10px;color:var(--muted);font-size:0.75rem;text-align:center;padding-bottom:10px;}
    .content-wrapper{margin-top:60px;}
    .queue-list {
      color: var(--text);
      font-size: 1.2rem;
      margin-top: 10px;
      max-height: 100px; /* Approx 3 rows: each row ~45px (1.2rem text + 5px margin) */
      overflow-y: auto;
      overflow-x: hidden;
      padding-right: 5px;
    }
    .queue-list::-webkit-scrollbar {
      width: 8px;
    }
    .queue-list::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
    }
    .queue-list::-webkit-scrollbar-thumb {
      background: var(--accent);
      border-radius: 4px;
    }
    .queue-list::-webkit-scrollbar-thumb:hover {
      background: #4a90e2;
    }
    #configDisplayText {
      padding-right: 8px;
    }
    .qr-float {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: #ffffff;
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      z-index: 1000;
    }
    .qr-float canvas {
      display: block;
    }
  </style>
  <script src="stomp.min.js"></script>
  <script src="qrcode.min.js"></script>
  <script src="purify.min.js"></script>
  <script src="metadata-loader.js"></script>
</head>
<body>
  <div class="room-code" id="roomCodeDisplay">Room: ----</div>
  <div class="conn-status" id="conn">Connecting…</div>

  <div class="content-container">
    <div class="muted small" style="text-align: center; margin-bottom: 15px; margin-top: 35px; color: var(--accent); font-size: 0.8rem;">
      Go to <span id="joinUrl" style="font-weight: bold;"></span> and enter the room code to join
    </div>
    
    <div id="meetingTopicDisplay" style="text-align: center; margin-bottom: 20px; color: var(--text); font-size: 1rem; font-weight: 600; display: none;">
      <div style="display:flex; align-items:center; justify-content:center; gap:8px; margin-bottom: 4px;">
        <div id="meetingTopicText" style="font-size: 1.1rem; font-weight:600;"></div>
      </div>
    </div>

    <!-- Poll in Progress Card (shown during ACTIVE poll) -->
    <div class="card" id="pollInProgressCard" style="display: none;">
      <div class="muted small">Poll in Progress</div>
      <div id="pollInProgressQuestion" class="big" style="font-size: 1.8rem; margin: 15px 0;">--</div>
      <div id="pollInProgressOptions" style="margin: 15px 0;">--</div>
      <div class="muted small">Votes Received</div>
      <div id="pollInProgressCount" class="timer ok" style="font-size: 2.8rem;">0</div>
    </div>

    <!-- Normal Speaker/Queue Cards (hidden during ACTIVE poll) -->
    <div id="normalDisplay">
      <div class="card">
        <div class="muted small">Current Speaker</div>
        <div id="currentSpeaker" class="big">--</div>
        <div id="currentRole" class="muted medium">--</div>
        <div class="muted small">Speaker Time</div>
        <div id="speakerTimer" class="timer ok">00:00</div>
      </div>

      <div class="card">
        <div class="muted small">Queue (<span id="queueCount">0</span> waiting)</div>
        <div id="queueList" class="queue-list">--</div>
      </div>
      
      <!-- Configuration Display Card -->
      <div class="card" id="configDisplay" style="display: none;">
        <div id="configHeader" style="display:flex; align-items:center; justify-content:space-between; cursor:pointer;">
          <div class="muted small" style="margin:0; font-weight: bold;">Meeting format:</div>
          <div id="configToggle" aria-expanded="false" style="font-size:1rem; color:var(--muted); margin-left:12px;">+</div>
        </div>
        <div id="configContent" style="display:none; margin-top:10px;">
          <div id="configDisplayText" style="font-size: 0.85rem; line-height: 1.5;"></div>
        </div>
      </div>
    </div>

    <!-- Poll Results Card -->
    <div class="card" id="pollResultsCard" style="display: none;">
      <div id="pollResultsHeader" style="display:flex; align-items:center; justify-content:space-between; cursor:pointer;">
        <div class="muted small" style="margin:0; font-weight: bold;">Last Poll Results</div>
        <div id="pollResultsToggle" aria-expanded="false" style="font-size:1rem; color:var(--muted); margin-left:12px;">+</div>
      </div>
      <div id="pollResultsContent" style="display:none; margin-top:10px;">
        <div id="pollResultsQuestion" class="medium" style="margin: 8px 0;">--</div>
        <div id="pollResultsData" style="margin: 8px 0;">--</div>
      </div>
    </div>
  </div>

  <div id="qrContainer" class="qr-float"></div>

  <script>
    // Get room code from URL parameter
    const urlParams = new URLSearchParams(window.location.search);
    const roomCode = urlParams.get('room');

    if (!roomCode || roomCode.length !== 4) {
      document.body.innerHTML = '<div class="card"><div class="big">Invalid room code</div></div>';
    } else {
      document.getElementById('roomCodeDisplay').textContent = `Room: ${roomCode}`;
      // Set join instructions with current browser URL
      const baseUrl = window.location.origin;
      document.getElementById('joinUrl').textContent = `${baseUrl}`;
      
      // Generate QR code for participant join link
      const participantJoinUrl = `${baseUrl}/participant.html?room=${roomCode}`;
      QRCode.toCanvas(participantJoinUrl, {
        width: 150,
        margin: 1,
        color: {
          dark: '#000000',
          light: '#ffffff'
        }
      }, function (error, canvas) {
        if (error) {
          console.error('QR code generation error:', error);
        } else {
          document.getElementById('qrContainer').appendChild(canvas);
        }
      });
    }

    // --- Utilities ---
    const fmt = ms => {
      const s = Math.max(0, Math.floor(ms/1000));
      const mm = String(Math.floor(s/60)).padStart(2,'0');
      const ss = String(s%60).padStart(2,'0');
      return `${mm}:${ss}`;
    };

    const setTimerClass = (el, warn, danger) => {
      el.classList.remove('ok','warn','danger');
      if (danger) el.classList.add('danger');
      else if (warn) el.classList.add('warn');
      else el.classList.add('ok');
    };

    // --- DOM refs ---
    const elConn = document.getElementById('conn');
    const elCurrentSpeaker = document.getElementById('currentSpeaker');
    const elCurrentRole = document.getElementById('currentRole');
    const elSpeakerTimer = document.getElementById('speakerTimer');
    const elQueueCount = document.getElementById('queueCount');
    const elQueueList = document.getElementById('queueList');
    const elJoinInstructions = document.getElementById('joinInstructions');
    const elPollResultsCard = document.getElementById('pollResultsCard');
    const elPollResultsQuestion = document.getElementById('pollResultsQuestion');
    const elPollResultsData = document.getElementById('pollResultsData');
    const elPollInProgressCard = document.getElementById('pollInProgressCard');
    const elPollInProgressQuestion = document.getElementById('pollInProgressQuestion');
    const elPollInProgressOptions = document.getElementById('pollInProgressOptions');
    const elPollInProgressCount = document.getElementById('pollInProgressCount');
    const elNormalDisplay = document.getElementById('normalDisplay');
    const elMeetingTopicDisplay = document.getElementById('meetingTopicDisplay');
    const elMeetingTopicText = document.getElementById('meetingTopicText');
    const elConfigDisplay = document.getElementById('configDisplay');
    const elConfigContent = document.getElementById('configContent');
    const elConfigToggle = document.getElementById('configToggle');
    const elConfigDisplayText = document.getElementById('configDisplayText');
    const elPollResultsContent = document.getElementById('pollResultsContent');
    const elPollResultsToggle = document.getElementById('pollResultsToggle');

    // Init: ensure collapsed by default
    if (elConfigContent) {
      elConfigContent.style.display = 'none';
      if (elConfigToggle) {
        elConfigToggle.textContent = '+';
        elConfigToggle.setAttribute('aria-expanded', 'false');
      }
    }

    // Init poll results: ensure collapsed by default
    if (elPollResultsContent) {
      elPollResultsContent.style.display = 'none';
      if (elPollResultsToggle) {
        elPollResultsToggle.textContent = '+';
        elPollResultsToggle.setAttribute('aria-expanded', 'false');
      }
    }

    // Toggle handler for config
    if (elConfigToggle && elConfigContent) {
      document.getElementById('configHeader').addEventListener('click', () => {
        const isExpanded = elConfigToggle.getAttribute('aria-expanded') === 'true';
        if (isExpanded) {
          elConfigContent.style.display = 'none';
          elConfigToggle.textContent = '+';
          elConfigToggle.setAttribute('aria-expanded', 'false');
        } else {
          elConfigContent.style.display = 'block';
          elConfigToggle.textContent = '−';
          elConfigToggle.setAttribute('aria-expanded', 'true');
        }
      });
    }

    // Toggle handler for poll results
    if (elPollResultsToggle && elPollResultsContent) {
      document.getElementById('pollResultsHeader').addEventListener('click', () => {
        const isExpanded = elPollResultsToggle.getAttribute('aria-expanded') === 'true';
        if (isExpanded) {
          elPollResultsContent.style.display = 'none';
          elPollResultsToggle.textContent = '+';
          elPollResultsToggle.setAttribute('aria-expanded', 'false');
        } else {
          elPollResultsContent.style.display = 'block';
          elPollResultsToggle.textContent = '−';
          elPollResultsToggle.setAttribute('aria-expanded', 'true');
        }
      });
    }

    // --- State ---
    let client = null;
    let currentState = null;
    
    // Descriptions loaded from server
    let descriptions = {
      meetingGoal: {},
      participationFormat: {},
      decisionRule: {},
      deliverable: {}
    };
    
    // Get option text from select element
    function getOptionText(selectId, value) {
      const select = document.getElementById(selectId);
      if (!select || !value) return null;
      for (let i = 0; i < select.options.length; i++) {
        if (select.options[i].value === value) {
          return select.options[i].text;
        }
      }
      return null;
    }

    // --- WebSocket ---
    function connect() {
      if (!roomCode) return;
      const scheme = location.protocol === 'https:' ? 'wss' : 'ws';
      const sock = new WebSocket(`${scheme}://${location.host}/ws`);
      client = Stomp.over(sock);
      client.debug = () => {}; // silence debug

      client.connect({}, () => {
        elConn.textContent = 'Connected';
        elConn.classList.add('ok');

        client.subscribe(`/topic/room/${roomCode}/state`, msg => {
          const state = JSON.parse(msg.body);
          currentState = state;
          updateDisplay(state);
        });
        
        // Subscribe to room destroyed event
        client.subscribe(`/topic/room/${roomCode}/destroyed`, msg => {
          const data = JSON.parse(msg.body);
          alert(data.message + '\n\nThis window will close.');
          window.close();
        });
        
        // Subscribe to room error events
        client.subscribe(`/topic/room/${roomCode}/error`, msg => {
          const error = JSON.parse(msg.body);
          alert(error.error + '\n\nThis window will close.');
          window.close();
        });

        // Join to get initial state
        client.send(`/app/room/${roomCode}/join`, {}, JSON.stringify({name:'Display', role:'Observer'}));
      }, () => {
        elConn.textContent = 'Disconnected';
        elConn.classList.remove('ok');
        setTimeout(connect, 2000);
      });
    }

    function updateDisplay(state) {
      // Update meeting topic
      if (state.roomConfig && state.roomConfig.topic) {
        elMeetingTopicDisplay.style.display = 'block';
        elMeetingTopicText.textContent = DOMPurify.sanitize(state.roomConfig.topic);
      } else {
        elMeetingTopicDisplay.style.display = 'none';
      }
      
      // Update configuration display
      if (state.roomConfig) {
        const config = state.roomConfig;
        let html = '';
        let hasAnySelection = false;
        
        if (config.participationFormat) {
          hasAnySelection = true;
          const metadata = descriptions.participationFormat[config.participationFormat];
          const optionText = metadata?.displayName || config.participationFormat;
          const desc = metadata?.description || 'NOT FOUND';
          html += `<div style="margin-bottom: 8px;"><strong>Participation Format:</strong> ${optionText}<br/><span style="color: rgba(255,255,255,0.7); font-size: 0.8rem;">${desc}</span></div>`;
        }
        
        if (config.meetingGoal) {
          hasAnySelection = true;
          const metadata = descriptions.meetingGoal[config.meetingGoal];
          const optionText = metadata?.displayName || config.meetingGoal;
          const desc = metadata?.description || 'NOT FOUND';
          html += `<div style="margin-bottom: 8px;"><strong>Meeting Goal:</strong> ${optionText}<br/><span style="color: rgba(255,255,255,0.7); font-size: 0.8rem;">${desc}</span></div>`;
        }
        
        if (config.decisionRule) {
          hasAnySelection = true;
          const metadata = descriptions.decisionRule[config.decisionRule];
          const optionText = metadata?.displayName || config.decisionRule;
          const desc = metadata?.description || 'NOT FOUND';
          html += `<div style="margin-bottom: 8px;"><strong>Decision Rule:</strong> ${optionText}<br/><span style="color: rgba(255,255,255,0.7); font-size: 0.8rem;">${desc}</span></div>`;
        }
        
        if (config.deliverable) {
          hasAnySelection = true;
          const metadata = descriptions.deliverable[config.deliverable];
          const optionText = metadata?.displayName || config.deliverable;
          const desc = metadata?.description || 'NOT FOUND';
          html += `<div style="margin-bottom: 8px;"><strong>Advance Thinking: Deliverable:</strong> ${optionText}<br/><span style="color: rgba(255,255,255,0.7); font-size: 0.8rem;">${desc}</span></div>`;
        }
        
        if (hasAnySelection) {
          elConfigDisplayText.innerHTML = html;
          // show card, but keep content collapsed by default
          elConfigDisplay.style.display = 'block';
          if (elConfigContent) {
            elConfigContent.style.display = 'none';
            if (elConfigToggle) {
              elConfigToggle.textContent = '+';
              elConfigToggle.setAttribute('aria-expanded', 'false');
            }
          }
         } else {
           elConfigDisplay.style.display = 'none';
         }
      }
      
      // Check if poll is active - show "Poll in Progress"
      if (state.pollState && state.pollState.status === 'ACTIVE') {
        elPollInProgressCard.style.display = 'block';
        elNormalDisplay.style.display = 'none';
        elPollResultsCard.style.display = 'none';
        
        elPollInProgressQuestion.textContent = DOMPurify.sanitize(state.pollState.question);
        elPollInProgressOptions.innerHTML = renderPollOptions(state.pollState.pollType, state.pollState.options);
        elPollInProgressCount.textContent = state.pollState.totalVotes || 0;
        return;
      }
      
      // Check if poll is ended - show only results
      if (state.pollState && state.pollState.status === 'ENDED') {
        elPollInProgressCard.style.display = 'none';
        elNormalDisplay.style.display = 'none';
        elPollResultsCard.style.display = 'block';
        
        // Populate content (but keep it collapsed by default)
        if (elPollResultsContent) {
          elPollResultsContent.style.display = 'none';
          if (elPollResultsToggle) {
            elPollResultsToggle.textContent = '+';
            elPollResultsToggle.setAttribute('aria-expanded', 'false');
          }
        }
        
        elPollResultsQuestion.textContent = DOMPurify.sanitize(state.pollState.question);
        
        let resultsHTML = '';
        if (state.pollState.pollType === 'GRADIENTS') {
          resultsHTML = renderGradientsResults(state.pollState.results, state.pollState.totalVotes);
        } else if (state.pollState.pollType === 'MULTISELECT' || state.pollState.pollType === 'MULTISELECT_MULTIPLE' || (state.pollState.options && state.pollState.options.length > 0)) {
          resultsHTML = renderMultiselectResults(state.pollState.results, state.pollState.totalVotes, state.pollState.options);
        } else if (state.pollState.pollType === 'YES_NO') {
          // YES/NO poll - bar chart display
          resultsHTML = renderYesNoResults(state.pollState.results, state.pollState.totalVotes);
          resultsHTML += `<div style="margin-top: 8px;" class="muted small">Total votes: ${state.pollState.totalVotes}</div>`;
        } else {
          // Fallback - simple text display
          resultsHTML = '<div style="margin-top: 8px;">';
          // Sort entries to ensure numeric order (OPT_1 to OPT_8)
          const sortedEntries = Object.entries(state.pollState.results).sort((a, b) => {
            const numA = parseInt(a[0].replace('OPT_', '')) || 0;
            const numB = parseInt(b[0].replace('OPT_', '')) || 0;
            return numA - numB;
          });
          for (const [option, count] of sortedEntries) {
            const percentage = state.pollState.totalVotes > 0 ? Math.round((count / state.pollState.totalVotes) * 100) : 0;
            const label = getVoteLabel(option, state.pollState.pollType);
            resultsHTML += `<div style="margin: 4px 0; font-size: 1.2rem;"><strong>${label}:</strong> ${count} (${percentage}%)</div>`;
          }
          resultsHTML += `<div style="margin-top: 8px;" class="muted small">Total votes: ${state.pollState.totalVotes}</div>`;
          resultsHTML += '</div>';
        }
        elPollResultsData.innerHTML = resultsHTML;
        return;
      }
      
      // Default: Show normal display (speaker/queue)
      elPollInProgressCard.style.display = 'none';
      elPollResultsCard.style.display = 'none';
      elNormalDisplay.style.display = 'block';
      
      // Current speaker
      if (state.current) {
        const c = state.current;
        elCurrentSpeaker.textContent = DOMPurify.sanitize(c.entry.name);
        elCurrentRole.textContent = DOMPurify.sanitize(c.entry.role);
      } else {
        elCurrentSpeaker.textContent = '--';
        elCurrentRole.textContent = '--';
      }

      // Queue - display speakers vertically
      elQueueCount.textContent = state.queue.length;
      if (state.queue.length > 0) {
        const queueHtml = state.queue.map((p, index) =>
          `<div style="margin-bottom: 5px;">${index + 1}. ${DOMPurify.sanitize(p.name)}</div>`
        ).join('');
        elQueueList.innerHTML = queueHtml;
      } else {
        elQueueList.innerHTML = '<div>--</div>';
      }

      // Show last poll results if available (for CLOSED state)
      if (state.pollState && state.pollState.lastResults) {
        elPollResultsCard.style.display = 'block';
        
        // Keep it collapsed by default
        if (elPollResultsContent) {
          elPollResultsContent.style.display = 'none';
          if (elPollResultsToggle) {
            elPollResultsToggle.textContent = '+';
            elPollResultsToggle.setAttribute('aria-expanded', 'false');
          }
        }
        
        const results = state.pollState.lastResults;
        elPollResultsQuestion.textContent = DOMPurify.sanitize(results.question);
        
        let resultsHTML = '';
        if (results.pollType === 'GRADIENTS') {
          resultsHTML = renderGradientsResults(results.results, results.totalVotes);
        } else if (results.pollType === 'MULTISELECT' || results.pollType === 'MULTISELECT_MULTIPLE' || (results.options && results.options.length > 0)) {
          resultsHTML = renderMultiselectResults(results.results, results.totalVotes, results.options);
        } else if (results.pollType === 'YES_NO') {
          // YES/NO poll - bar chart display
          resultsHTML = renderYesNoResults(results.results, results.totalVotes);
          resultsHTML += `<div style="margin-top: 8px;" class="muted small">Total votes: ${results.totalVotes}</div>`;
        } else {
          // Fallback - simple text display
          resultsHTML = '<div style="margin-top: 8px;">';
          // Sort entries to ensure numeric order (OPT_1 to OPT_8)
          const sortedEntries = Object.entries(results.results).sort((a, b) => {
            const numA = parseInt(a[0].replace('OPT_', '')) || 0;
            const numB = parseInt(b[0].replace('OPT_', '')) || 0;
            return numA - numB;
          });
          for (const [option, count] of sortedEntries) {
            const percentage = results.totalVotes > 0 ? Math.round((count / results.totalVotes) * 100) : 0;
            const label = getVoteLabel(option, results.pollType);
            resultsHTML += `<div style="margin: 4px 0; font-size: 1.2rem;"><strong>${label}:</strong> ${count} (${percentage}%)</div>`;
          }
          resultsHTML += `<div style="margin-top: 8px;" class="muted small">Total votes: ${results.totalVotes}</div>`;
          resultsHTML += '</div>';
        }
        elPollResultsData.innerHTML = resultsHTML;
      }
      
      updateTimer(state);
    }

    function getVoteLabel(vote, pollType) {
      if (pollType === 'YES_NO') {
        return vote === 'YES' ? 'Yes' : vote === 'NO' ? 'No' : vote;
      }
      const labels = {
        'OPT_1': '1 - Whole-hearted Endorsement',
        'OPT_2': '2 - Agreement with Minor Point of Contention',
        'OPT_3': '3 - Support with Reservations',
        'OPT_4': '4 - Abstain',
        'OPT_5': '5 - More Discussion Needed',
        'OPT_6': '6 - Don\'t Like But Will Support',
        'OPT_7': '7 - Serious Disagreement',
        'OPT_8': '8 - Veto'
      };
      return labels[vote] || vote;
    }
    
    function renderPollOptions(pollType, options) {
      let html = '<div style="margin: 10px 0;">';
      
      if (pollType === 'YES_NO') {
        // Simple Yes/No options
        html += '<div style="font-size: 0.95rem; color: rgba(255,255,255,0.8);">';
        html += '<div style="margin: 6px 0;">• Yes</div>';
        html += '<div style="margin: 6px 0;">• No</div>';
        html += '</div>';
      } else if (pollType === 'GRADIENTS') {
        // Gradient options (1-8 scale)
        const gradientOptions = [
          { num: '1', label: 'Whole-hearted Endorsement' },
          { num: '2', label: 'Agreement with Minor Point of Contention' },
          { num: '3', label: 'Support with Reservations' },
          { num: '4', label: 'Abstain' },
          { num: '5', label: 'More Discussion Needed' },
          { num: '6', label: 'Don\'t Like But Will Support' },
          { num: '7', label: 'Serious Disagreement' },
          { num: '8', label: 'Veto' }
        ];
        
        html += '<div style="font-size: 0.75rem; color: rgba(255,255,255,0.8);">';
        gradientOptions.forEach(opt => {
          html += `<div style="margin: 4px 0;"><strong>${opt.num}</strong> - ${opt.label}</div>`;
        });
        html += '</div>';
        html += '<div style="margin-top: 8px; font-size: 0.5rem; color: rgba(255,255,255,0.5); font-style: italic;">Reference: Kaner, S. (2014). Facilitator\'s Guide to Participatory Decision-Making. Third edition, Jossey-Bass: San Francisco, California, United States of America.</div>';
      } else if ((pollType === 'MULTISELECT' || pollType === 'MULTISELECT_MULTIPLE') && options && options.length > 0) {
        // Multiselect options
        html += '<div style="font-size: 0.95rem; color: rgba(255,255,255,0.8);">';
        options.forEach((optionLabel, index) => {
          html += `<div style="margin: 6px 0;">• ${DOMPurify.sanitize(optionLabel)}</div>`;
        });
        html += '</div>';
      }
      
      html += '</div>';
      return html;
    }
    
    function renderGradientsResults(results, totalVotes) {
      const gradientOptions = [
        { key: 'OPT_1', num: '1', label: 'Whole-hearted Endorsement' },
        { key: 'OPT_2', num: '2', label: 'Agreement with Minor Point of Contention' },
        { key: 'OPT_3', num: '3', label: 'Support with Reservations' },
        { key: 'OPT_4', num: '4', label: 'Abstain' },
        { key: 'OPT_5', num: '5', label: 'More Discussion Needed' },
        { key: 'OPT_6', num: '6', label: 'Don\'t Like But Will Support' },
        { key: 'OPT_7', num: '7', label: 'Serious Disagreement' },
        { key: 'OPT_8', num: '8', label: 'Veto' }
      ];
      
      let html = '<div style="margin: 16px 0; font-size: 0.75rem;">';
      html += '<div style="display: flex; align-items: flex-end; justify-content: space-between; height: 120px; margin-bottom: 8px;">';
      
      // Create bars for each option
      gradientOptions.forEach(opt => {
        const count = results[opt.key] || 0;
        const maxBarHeight = 120; // Match the container height
        const heightPx = totalVotes > 0 ? Math.max((count / totalVotes) * maxBarHeight, count > 0 ? 4 : 0) : 0;
        
        html += `<div style="flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; position: relative;">`;
        // Count above bar
        if (count > 0) {
          html += `<div style="font-weight: bold; font-size: 0.7rem; color: rgba(96,165,250,1); margin-bottom: 2px;">${count}</div>`;
        }
        // Bar
        html += `<div style="background: rgba(96,165,250,0.6); width: 80%; height: ${heightPx}px; border-radius: 4px 4px 0 0;"></div>`;
        html += `</div>`;
      });
      
      html += '</div>';
      
      // Number line with wrapped labels
      html += '<div style="display: flex; justify-content: space-between; border-top: 2px solid rgba(255,255,255,0.3); padding-top: 8px;">';
      
      gradientOptions.forEach(opt => {
        html += `<div style="flex: 1; display: flex; flex-direction: column; align-items: center; min-height: 100px; padding: 0 2px;">`;
        html += `<div style="font-weight: bold; font-size: 0.85rem; margin-bottom: 6px;">${opt.num}</div>`;
        // Wrapped label
        html += `<div style="font-size: 0.5rem; text-align: center; line-height: 1.2; word-wrap: break-word; overflow-wrap: break-word; hyphens: auto; max-width: 100%;">${opt.label}</div>`;
        html += `</div>`;
      });
      
      html += '</div>';
      html += '<div style="margin-top: 8px; font-size: 0.45rem; color: rgba(255,255,255,0.5); font-style: italic;">Reference: Kaner, S. (2014). Facilitator\'s Guide to Participatory Decision-Making. Third edition, Jossey-Bass: San Francisco, California, United States of America.</div>';
      html += '</div>';
      
      return html;
    }
    
    function renderMultiselectResults(results, totalVotes, options) {
      if (!options || options.length === 0) return '';
      
      let html = '<div style="margin: 16px 0;">';
      
      // Create horizontal bars for each option
      options.forEach((optionLabel, index) => {
        const optionKey = `OPT_${index}`;
        const count = results[optionKey] || 0;
        const percentage = totalVotes > 0 ? Math.round((count / totalVotes) * 100) : 0;
        const widthPercent = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
        
        html += `<div style="margin: 12px 0;">`;
        // Option label
        html += `<div style="font-weight: bold; margin-bottom: 4px; font-size: 0.95rem;">${DOMPurify.sanitize(optionLabel)}</div>`;
        // Bar container
        html += `<div style="display: flex; align-items: center; gap: 8px;">`;
        // Bar
        html += `<div style="flex: 1; background: rgba(255,255,255,0.1); border-radius: 4px; height: 24px; position: relative; overflow: hidden;">`;
        html += `<div style="background: rgba(96,165,250,0.6); width: ${widthPercent}%; height: 100%; border-radius: 4px; transition: width 0.3s ease;"></div>`;
        html += `</div>`;
        // Count and percentage
        html += `<div style="min-width: 80px; text-align: right; font-weight: bold; font-size: 0.9rem;">${count} (${percentage}%)</div>`;
        html += `</div>`;
        html += `</div>`;
      });
      
      html += '</div>';
      
      return html;
    }
    
    function renderYesNoResults(results, totalVotes) {
      const yesNoOptions = [
        { key: 'YES', label: 'Yes' },
        { key: 'NO', label: 'No' }
      ];
      
      let html = '<div style="margin: 16px 0;">';
      
      // Create horizontal bars for Yes/No
      yesNoOptions.forEach(opt => {
        const count = results[opt.key] || 0;
        const percentage = totalVotes > 0 ? Math.round((count / totalVotes) * 100) : 0;
        const widthPercent = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
        
        html += `<div style="margin: 12px 0;">`;
        // Option label
        html += `<div style="font-weight: bold; margin-bottom: 4px; font-size: 0.95rem;">${opt.label}</div>`;
        // Bar container
        html += `<div style="display: flex; align-items: center; gap: 8px;">`;
        // Bar
        html += `<div style="flex: 1; background: rgba(255,255,255,0.1); border-radius: 4px; height: 24px; position: relative; overflow: hidden;">`;
        html += `<div style="background: rgba(96,165,250,0.6); width: ${widthPercent}%; height: 100%; border-radius: 4px; transition: width 0.3s ease;"></div>`;
        html += `</div>`;
        // Count and percentage
        html += `<div style="min-width: 80px; text-align: right; font-weight: bold; font-size: 0.9rem;">${count} (${percentage}%)</div>`;
        html += `</div>`;
        html += `</div>`;
      });
      
      html += '</div>';
      
      return html;
    }

    function updateTimer(state) {
      if (!state.current) {
        elSpeakerTimer.textContent = '00:00';
        setTimerClass(elSpeakerTimer, false, false);
        return;
      }

      const c = state.current;
      const nowSec = Math.floor(Date.now() / 1000);
      let elapsedMs = c.elapsedMs;

      if (c.running) {
        elapsedMs += (nowSec - c.startedAtSec) * 1000;
      }

      elSpeakerTimer.textContent = fmt(elapsedMs);

      const warnThreshold = c.limitSec * 1000 * 0.8;
      const dangerThreshold = c.limitSec * 1000 * 0.95;
      setTimerClass(elSpeakerTimer, elapsedMs > warnThreshold, elapsedMs > dangerThreshold);
    }

    // --- Start ---
    if (roomCode) {
      // Load metadata first, then connect
      MetadataLoader.loadAll().then(metadata => {
        descriptions = metadata;
        connect();

        // Update timer every 250ms
        setInterval(() => {
          if (currentState) {
            updateTimer(currentState);
          }
        }, 250);
      }).catch(err => {
        console.error('Failed to load metadata, continuing anyway:', err);
        // Connect anyway with fallback values
        connect();

        // Update timer every 250ms
        setInterval(() => {
          if (currentState) {
            updateTimer(currentState);
          }
        }, 250);
      });
    }
  </script>
</body>
</html>